---
layout: post
title: "When to Break Abstractions"
date:   2020-05-22 01:00:00 -0800
categories: writing
draft: false
short: There's nothing quite like choosing the right wall to break through.
---

- the start doesnt match up with the ending: start is more about the 2 kinds of work
- the abstraction part explains how we get to nuts and bolts
- I think there's some kind of bridge needed.


I see my work as having two phases: nuts and bolts work, and creative work. I have a feeling that many programmers, writers, or any creative workers are unconsciously following this same system, and so I will elaborate my process clearly and you can decide if it matches yours. Since the core of the idea is simple, I’d also like to speculate and share some of the surprising consequences of this theory that I have myself discovered.

Let’s begin with the nuts and bolts work. This is what your education has trained you to do or trained you to train yourself to do. In programming, these are things like mastery of a language, framework, tool chain, version control, deployment environment, computing environment, etc. In writing this would be grammar, tense, voice, styles, technical bits like citation formatting, etc. They cost a time investment to learn and are not always easy to master. But, they are baseline, and they are trainable. Anyone can, with predictable results, learn to master it.

Nuts and bolts style work is characterized by the unconscious or autonomic actions that we perform as part of our job. I don't need to think about how to commit code to a repository, I just run the tape in my head. I don't need to think about how to compile and test my code because I have committed my coding environment to muscle memory. I basically don't need to think about generalizing and refactoring, and the automatic sort of test-writing, or how to use an API that I’ve employed several times in the past. When I write, the effort is in imaging the voice of a persona. I never think about how to hit the correct keys on the keyboard. This stuff all at one point took conscious effort, but became ingrained in repetition.

Nuts and bolts work, although automatic, doesn’t mean that it’s not valuable. You can probably find gainful employment putting this stuff to use, especially if it’s in a field like software. Also, as I alluded to, if you are a novice then you have to train yourself to automate the things which professionals have mastered. There’s some degree of subjectivity here.

Ok, but if there’s mostly-automatic nuts and bolts work, then there must be some kind of work that pushes the boundaries of what has become automatic. This is what I’d categorize as the creative work. In this kind of work, the mind formulates an abstract, and high-level idea with few constraints on implementation feasibility. The idea is first expressed in diagrams, bullet point sketches of features or experience goals, and in (often evangelical and caffeine-driven) conversations with co-workers as you mentally winnow down and grow out parts of the thought. I’d almost describe the interaction at this point as more like play: you toss around, stretch, place, and challenge it. Once you build up a clear enough mental picture of the target through high level expression, then you can take exploratory steps into the grounded nuts and bolts implementation of the idea.

This phase is dependent on having done the proper preparatory work of the nuts and bolts phase. Simply, before you can express a great idea, you must master the tools of your expression. For a programmer, this means a fluid confidence with a language and the relevant libraries that compose your creative substrate.

Ok, ok, this pattern is probably more or less obvious to most people since it appears in virtually any skill. You cannot become a great musician without first having mastered the basic chords, scales, and rhythms. An athlete doesn’t reach greatness who has not trained their body in the basics of physical form and movement. Children learn arithmetic before algebra. I needn’t make an obvious point because we know this stuff intuitively.

Then, for your entertainment and consideration, I’d like to offer some speculation on this pattern.

## Abstraction

Here’s a theory born out of this idea that we implement our creative ideas using skills and patterns which have become autonomic. The idea is that during this process of creative realization, we discover our ideas generalize to an abstraction. If the abstraction encapsulates a creative thought well, then the abstraction becomes another person’s tool to be learned as something in the nuts and bolts knowledge bucket. In a sense, we create commonly understood expressions for creative patterns.

Not clear? It’s easy: some guy gets tired of writing jump statements in assembly and implements the concept of a loop in a high level language. Someone else is sick of writing mappers between an object and a database row and so abstracts this mapping into an Object Relational Mapper and no longer writes the mappings himself. Someone gets tired of writing neural nets from scratch and creates a library like tensorflow. Take any high level abstraction, and it’s probably a natural conclusion in the creator’s mind to encapsulate an idea or process so that they can free up some variables in their mental space to tackle other challenges instead of fiddling around with the low level nuts and bolts.

You know, I think I’ve failed you. This isn’t a new idea. The process of abstraction is well known to programmers that wield high level libraries and languages (all of them). You’re basically admitting all this if you proclaim, “I am a java/ruby/python/javascript/etc/etc/etc programmer”. 

### Breaking Down Abstractions

So here’s a challenge that I haven’t actually seen well answered on this topic: when is it appropriate to peel back the layers of abstraction and learn how an idea was encapsulated? I have no answers but I have some anecdotes. 

I’ve been a programmer on a team that inherited a login system. It was not just any login system, it was one that the company hadn’t patched for over two years (the pace we moved, there really were probably more urgent priorities). No one at our office had a strong idea of what problem it was solving beyond the very basic mechanics: authenticate a user, issue the user a token which is then used by an application to access our APIs. As it soon happened, my team got additional feature requests on top of these basic requirements, and this put us in a bind. How can we implement revocation of tokens if the boxed product doesn’t implement it? The choice seemed to present itself as this: we could either try to convince open source contributors to add this feature, learn it ourselves and implement it, or go down the route of cracking open the abstraction and reengineering a version of the product that fit our needs.

When making the decision on whether or not to build, I drew from a particularly embarrassing experience I’d had years earlier at an internship where I was tasked with re-writing a debugging tool from WinForms to Microsoft’s then-new WFP framework. The embarrassing thing wasn’t in how trivial seeming this intern task was, it’s that I never got the thing to fully work like the old tool, and it was more or less a waste of two months. I spent most of my time fumbling around stackoverflow trying to find magic lines of XML code that would rotate my DataGrids a particular way. My hapless copy paste job only produced a mess of basically useless code. If I had to diagnose my past behavior knowing what I know now, I’d say that my problem was that I didn’t make any effort to understand the abstraction. What would have been a more productive use of intern time would have been to learn how one builds windowing framework by understanding the layers of abstractions involved in framing, alignment, component design, and style application. As I said, I believe that having a foundational understanding of the nuts and bolts is a prerequisite for building something more than just demoware on top of it.

Back to the login system decision. This is an area where, having enough failure under my belt, I understood the correct option was almost certainly to break down the abstraction in order to build a deep understanding of the problem. The process of manifesting an idea is the process of understanding it. In the process of rewriting our login system, I had the opportunity to learn the practicalities of cryptography,  key management, performance and security tradeoffs, browser-based web application basics, and (somewhat ruefully) a whole lot of particularities of the java keystore API. The cost was obviously time, and effort, but the benefits were both to me and the team. I leveled up as a programmer, and the company got a login system that was tailored to the use-cases they needed in their product. 

### Abstraction Formation

I gave an anecdote on how to choose when to break down an existing abstraction, and now I’d like to give some speculation on the process of forming new abstractions. This metaphor will be familiar to anyone who has taken some basic chemistry. My speculation is the process of abstraction is like a chemical process which first requires an amount of activation energy to coax the reaction over a barrier, and then into an area of lower energy where the reaction carries on by its own momentum. Furthermore, I speculate that new companies that would not have been able to break the activation barrier on their own will appear during the momentum phase.

Here’s an anecdote. Consider login protocols for web services (seeing a trend?). Back in 2010, few sites integrated with each other. One experience that is familiar to many people is having to give a banking application like Mint your bank website’s username and password directly. The risk here is obviously huge since Mint could in theory use your credentials to siphon off money to spend on lavish tech parties or something. So, security-minded people working for companies that would commonly benefit from a safe protocol set about iterating on, and inventing a way for two web applications to delegate portions of functionality to each other. This all happens with the end user’s consent and without sharing passwords. One of the important creative insights was the separation of different actors involved in the protocol. Namely, they termed client applications, resource servers, authorization servers, and the resource owner. They defined how these actors relate to one another in the various scenarios big web companies encountered. Like, other protocols specified in RFCs, the authors left enough flexibility in the protocol so that it could evolve as web and security standards changed. After the initial activation energy was injected into the system, the outcome was the OAuth protocol which allows sites to share information on a user’s behalf and only within a specific scope of functionality. 

Fitting my hypothesis, new businesses formed in the wake of the discovery of these protocols. Okta and other identity integrator platforms act as a registry of applications which all need one thing: proof of your identity and a few claims about your personal information. This is incredibly valuable from an IT organization’s efficiency standpoint. Another familiar example is the wealth of apps built on top of social media platforms, and most of them use these protocols to establish who the user is and tap into their network so they can spread awareness of the app to a bigger audience. 

I have to imagine there are some industries which haven’t been pulled into the current of sharing access and breaking down the walled garden-type applications. I personally have seen that the auto industry has not yet made this switch: why can’t you unlock your car as easily as you can swipe down and turn the flashlight on with your phone? I think this is coming, but slowly since unlocking your personally-owned vehicle won’t have viral network effects like sharing app data from Facebook might on a web platform. A physical good like a car will gain more value from these kinds of sharing protocols when the good transitions from personal ownership to shared service model. In that case, the protocols become a baseline abstraction for launching the business.

I digress. My point is, following an innovation, companies will spring up in their path as surely as a few cups of coffee will cause writing to spontaneously flow from my finger tips.

## Conclusion

I presented you with a few obvious ideas. The first is that one masters the practical domain before being able to express creative processes.  The second is that fields are built on a language of abstraction because smart people that came before you encapsulated problems into abstractions, reducing the mental load required to employ higher level ideas. One challenge that you’ll face during the creative process is choosing when to dig into abstractions rather than limiting yourself to their surface level features. Finally, abstractions might take an incredible amount of activation energy to be born out into the world, but once created, it takes far less effort to learn them and adopt the idea to new industries, providing a fertile ground for new businesses.

That’s all I got. I hope I can spot some areas where new abstractions have just peaked in their initial development and are moving onto the proliferation phase and ride in on that wave.
